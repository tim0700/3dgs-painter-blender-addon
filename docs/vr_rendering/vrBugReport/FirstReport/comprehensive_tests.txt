
================================================================================
COMPREHENSIVE TEST SUITE FOR VR GAUSSIAN RENDERING SYSTEM
================================================================================

TEST SET 1: gaussian_data.h - Struct Validation Tests
================================================================================

TEST 1.1: GaussianPrimitive Size Validation
-------------------------------------------
Expected: sizeof(GaussianPrimitive) == 56 bytes
Actual Size Calculation:
  - position[3]:   3 floats = 12 bytes
  - color[4]:      4 floats = 16 bytes  
  - scale[3]:      3 floats = 12 bytes
  - rotation[4]:   4 floats = 16 bytes
  - Total:        14 floats = 56 bytes
Status: ✓ PASS (Size correct)

TEST 1.2: Memory Alignment
-------------------------------------------
Issue: alignas(4) on struct but fields not explicitly padded
Test: Verify padding calculation
  - With alignas(4), fields should be 4-byte aligned
  - float arrays are naturally 4-aligned
  - But across 56 bytes, alignment may vary by platform
Action: Add explicit padding fields or use #pragma pack

TEST 1.3: Shared Memory Magic Number
-------------------------------------------
Test: MAGIC_NUMBER = 0x33444753 ("3DGS" in little-endian)
Expected: 0x33444753
Verification: 
  '3' = 0x33, 'D' = 0x44, 'G' = 0x47, 'S' = 0x53
  Little-endian: 0x53474433 (WRONG!)
  Big-endian: 0x33444753 (CORRECT!)
Status: ✗ FAIL - Comment says little-endian but hex is big-endian
Fix: Change comment or verify endianness on target platform


================================================================================
TEST SET 2: gaussian_renderer.cpp - Missing Function Pointers
================================================================================

TEST 2.1: glDrawArraysInstanced Not Loaded
-------------------------------------------
Code at end:
  pfn_glDrawArraysInstanced(GL_TRIANGLES, 0, 6, count);

Loaded in LoadRendererExtensions():
  LOAD_GL(glCreateShader);
  LOAD_GL(glShaderSource);
  ... (20+ others)
  BUT NO: LOAD_GL(glDrawArraysInstanced);

Result: ✗ FAIL - nullptr dereference when called
Fix: Add:
  LOAD_GL(glDrawArraysInstanced);

TEST 2.2: Fragment Shader Incomplete
-------------------------------------------
Code cutoff at:
  "// Use the Gaussian's color with alpha"

Missing:
  - fragColor = vColor * alpha;
  - No closing brace for main()
  - No closing triple-quote

Status: ✗ FAIL - Shader won't compile
Fix: Complete shader:
  fragColor = vColor * alpha;
  }
  )";

TEST 2.3: RenderFromPrimitivesWithMatrices() Not Defined
-------------------------------------------
Called in xr_dispatch.cpp line ~340:
  GetGaussianRenderer().RenderFromPrimitivesWithMatrices(...)

Exists in gaussian_renderer.h header?
  CHECK: Would need to see header file

Result: ✗ FAIL - Unresolved external symbol at link time
Fix: Implement the function in gaussian_renderer.cpp


================================================================================
TEST SET 3: projection_layer.cpp - Syntax and Logic Errors
================================================================================

TEST 3.1: LoadGLExtensions() Missing Closing Brace
-------------------------------------------
Code snippet:
  static bool LoadGLExtensions() {
    if (g_glExtensionsLoaded) return true;
    ... (function pointer loads)
    g_glExtensionsLoaded = (pfn_glGenFramebuffers && ...);
    return g_glExtensionsLoaded;
    // <-- MISSING CLOSING BRACE

  // Logging function starts here
  static void LogProj(...) {

Result: ✗ FAIL - Compilation error (expected '}' before LogProj)
Fix: Add closing brace after return statement:
  return g_glExtensionsLoaded;
  }  // <-- ADD THIS

TEST 3.2: CreateFBOs() Implementation Incomplete
-------------------------------------------
Called in Initialize():
  if (!CreateFBOs()) {
    LogProj("Failed to create FBOs");
    return false;
  }

But CreateFBOs() implementation is cut off in provided code

Result: ✗ FAIL - Function body not shown
Fix: Show or implement complete CreateFBOs() method:
  - Should create framebuffers for each eye
  - Should attach swapchain textures
  - Should validate FBO status

TEST 3.3: Uninitialized Member Variables
-------------------------------------------
Constructor:
  ProjectionLayer::ProjectionLayer() {
    for (int i = 0; i < EYE_COUNT; i++) {
      m_views[i] = { XR_TYPE_VIEW };
    }
  }

Missing initialization of:
  - m_instance (used in LoadOpenXRFunctions() without check)
  - m_session (used in CreateStereoSwapchain() without check)
  - m_width (hardcoded as 1024 elsewhere)
  - m_height (hardcoded as 1024 elsewhere)
  - m_functionsLoaded (used in LoadOpenXRFunctions())
  - m_fbos[2] (assumed zero-initialized)
  - m_swapchains[2] (assumed zero-initialized)

Result: ✗ FAIL - Undefined behavior if Initialize() not called first
Fix: Initialize all members in constructor:
  ProjectionLayer::ProjectionLayer()
    : m_instance(XR_NULL_HANDLE)
    , m_session(XR_NULL_HANDLE)
    , m_width(0)
    , m_height(0)
    , m_functionsLoaded(false)
    , m_localSpace(XR_NULL_HANDLE) {
    for (int i = 0; i < EYE_COUNT; i++) {
      m_views[i] = { XR_TYPE_VIEW };
      m_fbos[i] = 0;
      m_swapchains[i] = XR_NULL_HANDLE;
    }
  }

TEST 3.4: GetLayerState() Not Defined in This File
-------------------------------------------
Called on line ~280:
  auto& state = GetLayerState();

But GetLayerState() is defined in xr_dispatch.cpp:
  LayerState& GetLayerState() {
    return g_layerState;
  }

Likely included via xr_dispatch.h, but could cause circular dependency

Result: ⚠️  WARN - Depends on external declaration
Fix: Verify #include "xr_dispatch.h" is included


================================================================================
TEST SET 4: xr_dispatch.cpp - Memory and Logic Errors
================================================================================

TEST 4.1: Memory Leak - allLayers Vector Dangling Pointer
-------------------------------------------
Code in gaussian_xrEndFrame():
  std::vector allLayers;
  allLayers.reserve(frameEndInfo->layerCount + 1);

  for (uint32_t i = 0; i < frameEndInfo->layerCount; i++) {
    allLayers.push_back(frameEndInfo->layers[i]);
  }
  allLayers.push_back(projLayerHeader);

  XrFrameEndInfo modifiedEndInfo = *frameEndInfo;
  modifiedEndInfo.layerCount = static_cast(allLayers.size());
  modifiedEndInfo.layers = allLayers.data();  // <-- POINTER TO LOCAL VECTOR!

  return g_layerState.next_xrEndFrame(session, &modifiedEndInfo);
  } // <-- allLayers DESTROYED HERE, pointer now invalid!

Result: ✗ FAIL - Use-after-free bug
Scenario:
  1. allLayers.data() points to vector's internal buffer
  2. modifiedEndInfo.layers = allLayers.data()
  3. Function returns, allLayers destroyed
  4. next_xrEndFrame() tries to access dangling pointer
  5. Crash or undefined behavior

Fix: Make vector static or pass by reference:
  // Option 1: Keep vector alive
  static std::vector allLayers;
  allLayers.clear();
  allLayers.reserve(frameEndInfo->layerCount + 1);
  ... (same code)

  // Option 2: Store in state struct for lifetime management
  g_layerState.injected_layers.clear();
  g_layerState.injected_layers.reserve(frameEndInfo->layerCount + 1);
  ... (copy layers)
  modifiedEndInfo.layers = g_layerState.injected_layers.data();

TEST 4.2: Null Pointer Check Missing for frameEndInfo->layers
-------------------------------------------
Code:
  for (uint32_t i = 0; i < frameEndInfo->layerCount; i++) {
    allLayers.push_back(frameEndInfo->layers[i]);  // <-- May be nullptr!
  }

Result: ✗ FAIL - No null check on frameEndInfo->layers
Fix: Add validation:
  if (frameEndInfo->layers == nullptr && frameEndInfo->layerCount > 0) {
    LogXr("ERROR: frameEndInfo->layers is null but layerCount=%d",
          frameEndInfo->layerCount);
    return g_layerState.next_xrEndFrame(session, frameEndInfo);
  }

TEST 4.3: Unsafe Matrix Array Access
-------------------------------------------
Code:
  const float* pythonViewMatrix = buffer->header.view_matrix;
  bool hasPythonMatrix = (pythonViewMatrix[0] != 0.0f || pythonViewMatrix[5] != 0.0f);
  ... later:
  LogXr("VIEW MATRIX: hasPython=%d, trans=(%.2f,%.2f,%.2f)",
        hasPythonMatrix ? 1 : 0,
        viewMatrix[12], viewMatrix[13], viewMatrix[14]);

Result: ✗ FAIL - Array bounds not validated
Issue:
  - view_matrix is float[16], so indices 0-15 are valid
  - Accessing [12], [13], [14] is OK for 4x4 matrix
  - BUT: Code doesn't validate buffer->header is initialized

Fix: Add bounds and validity checking:
  if (!buffer || !buffer->header.view_matrix) {
    LogXr("ERROR: Invalid buffer or view_matrix");
    return g_layerState.next_xrEndFrame(session, frameEndInfo);
  }

  // Validate matrix looks reasonable (not all zeros)
  float matrixMagnitude = 0;
  for (int i = 0; i < 16; i++) {
    matrixMagnitude += abs(buffer->header.view_matrix[i]);
  }
  if (matrixMagnitude < 0.1f) {
    LogXr("WARNING: view_matrix appears uninitialized (magnitude=%.2f)", 
          matrixMagnitude);
  }


================================================================================
TEST SET 5: vr_operators.py - Python Issues
================================================================================

TEST 5.1: _sync() Method Uses Undefined Attributes
-------------------------------------------
Code in THREEGDS_OT_VRPaintStroke._end_paint():
  count = self._scene_data.count if self._scene_data else 0
  self.report({'INFO'}, f"Painted {count} gaussians")

Issue:
  - self._scene_data comes from get_or_create_paint_session()
  - This function not defined in provided code
  - No guarantee scene_data has 'count' attribute
  - If scene_data is dict, use scene_data.get('count', 0) instead

Result: ✗ FAIL - AttributeError at runtime if count doesn't exist
Fix: Add defensive attribute access:
  count = 0
  if self._scene_data:
    count = getattr(self._scene_data, 'count', 
                    self._scene_data.get('count', 0) 
                    if isinstance(self._scene_data, dict) else 0)

TEST 5.2: Matrix Update Callback Timing Issue
-------------------------------------------
Code:
  def _vr_matrix_update_callback():
    mgr = get_vr_session_manager()
    if not mgr.is_session_running():
      _vr_matrix_updater_running = False
      return None

Issue:
  - VR session could stop between calls
  - No locking on _vr_matrix_updater_running
  - Multiple threads could race

Result: ⚠️  WARN - Potential race condition
Fix: Use threading.Lock():
  import threading
  _vr_matrix_updater_lock = threading.Lock()
  _vr_matrix_updater_running = False

  def _vr_matrix_update_callback():
    global _vr_matrix_updater_running
    with _vr_matrix_updater_lock:
      if not _vr_matrix_updater_running:
        return None


================================================================================
TEST SET 6: vr_freehand_paint.py - Python Logic Errors
================================================================================

TEST 6.1: get_controller_tip() Quaternion Construction
-------------------------------------------
Code:
  aim_rot_tuple = xr.controller_aim_rotation_get(context, hand_index)
  # Convert tuple to Quaternion (w, x, y, z)
  # Note: XR API returns (w, x, y, z) format
  aim_rot = Quaternion(aim_rot_tuple)

Issue:
  - Blender's Quaternion constructor accepts:
    * Quaternion((w, x, y, z))
    * Quaternion(w=w, x=x, y=y, z=z)
    * angle=..., axis=...
  - But mathutils.Quaternion actually expects sequence (w,x,y,z)
  - Need to verify Blender XR returns correct format

Result: ⚠️  WARN - Format mismatch possible
Test: Verify with actual Blender code:
  xr.controller_aim_rotation_get() returns what?

Fix: Add validation:
  aim_rot_tuple = xr.controller_aim_rotation_get(context, hand_index)
  if len(aim_rot_tuple) != 4:
    print(f"[VR Paint] ERROR: Expected 4-tuple for rotation, got {len(aim_rot_tuple)}")
    return None

  try:
    aim_rot = Quaternion(aim_rot_tuple)
  except TypeError:
    # Try alternative format (maybe x,y,z,w?)
    aim_rot = Quaternion((aim_rot_tuple[3], aim_rot_tuple[0], aim_rot_tuple[1], aim_rot_tuple[2]))
    print(f"[VR Paint] Converted rotation format to: {aim_rot}")

TEST 6.2: _continue_stroke() Method Incomplete
-------------------------------------------
File cuts off at:
  norms_np = np.array(normal_vec, dtype=np.float32)
  # ... missing rest of method

Result: ✗ FAIL - Method incomplete, can't paint
Fix: Complete the method (see next test)

TEST 6.3: Missing Implementation of Stroke Update
-------------------------------------------
After getting controller position and normal, should:
  1. Call self._session.stroke_painter.update_stroke(...)
  2. Sync to viewport
  3. Update last sample position

Expected code:
  self._session.stroke_painter.update_stroke(
    position=pos_np,
    normal=normal_np
  )
  self._sync_to_viewport(context)
  self._session.last_sample_pos = position


================================================================================
TEST SET 7: Integration Tests
================================================================================

TEST 7.1: Shared Memory Communication
-------------------------------------------
Scenario: Write gaussians from Python, read in C++

C++ expects (gaussian_data.h):
  struct SharedMemoryBuffer {
    SharedMemoryHeader header;
    GaussianPrimitive gaussians[MAX_GAUSSIANS];
  }

Python writes:
  writer.write_gaussians_numpy(positions, colors, scales, rotations)

Test:
  1. Write 100 test gaussians from Python
  2. Read in C++ via SharedMemoryReader
  3. Verify count, positions, colors match
  4. Check magic number and version

TEST 7.2: OpenGL Function Pointer Loading
-------------------------------------------
Scenario: Ensure all GL extensions load before use

Current status:
  - glCreateShader: ✓ LOADED
  - glCompileShader: ✓ LOADED  
  - glCreateProgram: ✓ LOADED
  - glUseProgram: ✓ LOADED
  - glDrawArraysInstanced: ✗ NOT LOADED (BUG)
  - glUniform4fv: ✗ NOT LOADED (BUG)

Test: Call LoadRendererExtensions() and verify all pointers non-null

TEST 7.3: VR Controller Input to Paint Action
-------------------------------------------
Scenario: User presses B button, should paint

Steps:
  1. XR runtime sends B button event
  2. THREEGDS_OT_VRPaintStroke.invoke() called
  3. Paint session initialized
  4. modal() called with timer events
  5. Controller position sampled each frame
  6. Gaussians generated at position
  7. Viewport updated with new gaussians
  8. B button released
  9. Stroke finished

Potential failures at each step:
  - VR session not started
  - Paint session initialization fails
  - Timer not firing
  - Controller position returns None
  - Scene data update fails
  - Viewport renderer not registered


================================================================================
EXECUTION PRIORITY
================================================================================

MUST FIX FIRST (Compilation/Linking):
1. Fix LoadGLExtensions() missing brace in projection_layer.cpp
2. Add missing LOAD_GL calls in gaussian_renderer.cpp
3. Implement RenderFromPrimitivesWithMatrices() in gaussian_renderer.cpp
4. Complete fragment shader in gaussian_renderer.cpp

MUST FIX SECOND (Runtime Crashes):
5. Fix memory leak in xr_dispatch.cpp (allLayers vector)
6. Add null checks for frameEndInfo->layers
7. Add matrix validation before access
8. Complete _continue_stroke() in vr_freehand_paint.py

MUST FIX THIRD (Correctness):
9. Initialize member variables in projection_layer.cpp
10. Fix Quaternion construction in vr_freehand_paint.py
11. Add thread safety to vr_operators.py
12. Implement missing LocateViews(), GetViewMatrix(), GetProjectionMatrix()

SHOULD FIX (Quality):
13. Add bounds checking and validation throughout
14. Complete error handling in shaders
15. Add timeout handling for timer callbacks
16. Implement proper logging/debugging


================================================================================
